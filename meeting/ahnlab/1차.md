# 🔴 준비 시작

## 🟠 자기소개

```text
안녕하세요 6년차 개발자 최준호입니다.
저는 코드블럭이라는 PG사에서 개발을 시작하여 현재 카카오VX에서 근무하고 있습니다.
해당 회사들을 통해 골프 예약 시스템, ERP 연동 시스템, 관리자툴 등 프로젝트들을 진행했으며
프로젝트들을 통해서는 레거시 개선, 트러블 슈팅, 성능 최적화, 협업의 경험을 쌓아왔습니다.

플랫폼 서비스는 고객이 가장 먼저 만나게 되는 사업의 업굴이라 생각합니다.
그렇기에 안정성과 신뢰성이 중요한 가치라고 보고 있고요.

저의 장점인 운영 안정성, 협업 능력은 플랫폼서비스 분야에서 안정성과 신뢰성에 기여할 수 있고
팀 문화인 문제에 대한 창의적 해결, 효율적인 자동화는 협업을 진행하며 제가 개발자로서 중요하게 생각하는 가치관과 맞닿아 있습니다. 
안랩에서 훌륭한 동료들과 함께 성장하고 기여하는 인원으로 함께하고 싶습니다. 감사합니다.
```

## 🟠 이직 사유

```text
최근 회사가 구조조정과 희망퇴직을 반복하면서 프로젝트가 무기한 보류되거나 중단되는 경우가 많아졌습니다. 
특히 제가 담당하던 핵심 프로젝트들도 인력 이탈로 인해 더 이상 진행이 어려워졌고, 안정적인 개발 환경에서 성장하고 싶다는 생각이 강해져 이직을 결심하게 되었습니다.
```

## 🟠 학점이 낮은 사유

```text
대학교 재학시 가정형편이 어려워져 생활비를 부담해야했고 고등학교 졸업부터 취업전까지 알바를 병행해야 했습니다.
그로인해 학점 관리에 아쉬움은 있었지만, 정보처리기사 자격증 취득, 부트캠프 과정 수료를 통해 부족한 부분을 채우려 노력하였습니다.
```

## 🟠 지원 동기

```text
고등학교 시절, ‘무릎팍도사’에 출연한 안철수 박사님의 이야기를 통해 개발이 단순한 기술을 넘어 사회에 기여할 수 있는 도구가 될 수 있다는 점을 처음으로 깨달았습니다.
특히 세계 최초의 백신인 V1 개발자이자, 안랩의 창립자로서 안 박사님이 보여주셨던 철학과 실천은 개발자로서의 방향성과 가치관에 큰 영향을 주었습니다.
현재도 안랩은 V3 Lite를 비롯한 다양한 보안 솔루션을 통해 그 철학을 이어가고 있는 기업이라고 생각하며, 저 역시 그 철학을 함께하고 싶다는 동기로 지원하게 되었습니다.
```

## 🟠 프로젝트 설명

1. 가장 의미있는 프로젝트

```text
골프장 ERP 연동 시스템이 가장 의미 있는 프로젝트입니다.
그 이유로는 해당 시스템의 주 담당자이기도 했고 레거시를 개선, OOM 문제를 해결한 경험이 있기 때문입니다.
```

2. 협업한 경험

```text
셔틀버스 API 개발이 협업한 경험이라 할수 있을것 같습니다.
당시에 팀장님과 제가 한팀이 되어 진행했었고 사실 팀장님은 팀 관리와 다른 업무로 바빠 백엔드쪽은 제가 주로 리딩하며 진행했기 때문입니다.
기획, 디자인, 사업, 앱팀과 협업을 진행했고 보안 문제로 보안팀과도 협업을 진행하게 되었습니다.
```

3. 갈등 경험 (상사)

```text
상사와의 갈등은 하드코딩 이슈로 갈등이 있었습니다.
하지만 서비스의 형태와 회사의 방향성에 맞게 우선은 서비스를 위한 코드를 작성하고 이후 리팩토링이 되기 쉽도록 짜기 위해 노력하였습니다.
예를 들어 하드코딩의 경우 하드코딩 패턴에 따라 class로 분리하여 작성하도록 했고 이후에 주석과 기간 조건들을 필수로 입력하도록 하여 기간이 종료되었을 때 코드를 삭제할 수 있도록 하였습니다.
```

4. 갈등 경험 (팀원)

```text
docker, jenkins를 도입하며 팀원들과의 의견을 주고받은 경험이 있습니다.
당시 팀원들은 저보다 리눅스 활용 능력이 뛰어났기 때문에 현재 배포 프로세스에 대해 불만이 없었습니다.
오히려 docker와 jenkins의 도입은 팀원들에게 부담이라는 의견이 있었는데요.
이 부분을 해결하기 위해 팀원들에게 혹시라도 문제가 발생한다면 제가 직접 가서 도와주고 같이 문제를 해결해줄 수 있다고 했고
팀원들을 위한 교육 시간도 마련하기로 하였습니다. 대표님과 팀장님에게는 문서와 실습 과정을 직접 시연하여 현재 배포가 1시간이 걸리는 것에 비해
새로운 인원이 투입된다 하여도 5분안에 배포가 가능하고 jenkins의 동작도 기존 리눅스 명령어를 그대로 사용함으로써 현재 인원들도 금방 적응할 수 있도록 적용할 수 있다는 것을 보였습니다.
그 결과 대표님과 팀장님의 승인으로 회의시간을 따로 잡아주셔서 팀원들에게 시연과 교육을 진행하였고 실제로 제가 퇴사 이후에도 현재도 도커와 jenkins를 통해 잘 배포하고 있다고 들었습니다.
```

5. 시스템 구성도 그려보기

```text
화이트보드로 그리기!
```

## 🟠 기본 cs
1. JVM
    - class loader, runtime data area, execution engine으로 구성
    - class loader는 class를 실제 실행하기 위한 코드로 읽어오고 jvm에 배치해주는 역할
    - runtime data area는 jvm의 메모리 영역
    - execution engine은 실제 코드를 한줄씩 실행하는 interpreter와 병렬 실행하는 jit compiler, gc로 구성
    - runtime data area는 method area, heap area, stack area, native area, pc register로 구성
    - method에서는 static, method 등 프로그램이 실행할때 생성되고 명시적으로 null로 처리할때까지 살아있는 모든 쓰레드들이 공유하는 객체들이 존재
    - heap은 new 객체로 생성된 객체들이 존재
    - stack은 메서드의 실행 순서와 메서드 내 필드들이 임시로 저장되는 공간
    - native area는 java에서 os의 기능 실행하기 위한 공간
    - pc register는 각 스레드가 어떤 명령어를 실행중인지 명령어 주소 저장 공간
2. GC
   - young, old 영역
   - young은 eden(최초 생성), survive0, survive1 영역으로 나누어서 구분됨
   - GC의 종류는 young을 지우는 Minor GC, old를 지우는 Major GC로 구분됨 
   - 영역 메모리가 가득 차면 영역 메모리 gc
   - 메모리가 gc에 오랫동안 걸리지 않아 old가 계속 차게 되면 메모리 사용량 증가
   - gc가 자주 발생하면 응답 지연 발생 가능성이 높다 (stop the world)
   - 기본 gc 알고리즘은 G1으로 설정되어 있음
   - GC 튜닝은 정말 최후 최후의 방법임. 코드레벨에서 먼저 개선할 것
3. hash 구조
   - 해시 function
    - 입력 받은 데이터를 해시 값으로 변환
   - 해시 테이블
     - 변환 된 값을 key로 key-value 형태로 저장하는 테이블
   - 해싱
     - 키값을 해시 함수를 통해 해시 테이블로 저장하는 과정
   - 해시 충돌
     - 해시 값을 만들었을때 중복되는 경우를 해시 충돌이라 한다.
     - 충돌 해결로는 open address 또는 chaning 기법이 있고 java는 chaning 기법을 사용한다.
     - linked list 형태로 충돌되는 데이터를 저장하다가 특정 조건 이상 충돌이 발생하면 트리 구조로 변경한다.
       - java의 특정 조건은 맵의 총 크기가 64 이상이고 해당 충돌값이 8개 이상인 경우 트리로 변경한다.
       - 만약 맵 총 크기가 64 미만이고 충돌이 8번 이상 발생한 경우는 resize()를 통해 해시를 재생성하여 해시테이블을 새롭게 만들어 정렬한다.
     - 데이터가 많은 경우 트리구조로 변경되어 읽기시 최대 O(n) 복잡도가 걸릴 수 있는 부분은 O(log n)으로 줄이기 위함니다.
4. list 구조
    - ArrayList 기본 구조
        - 조회가 빠르다. 삽입/삭제시 재생성해야 되므로 느리다.
        - 최초 생성시 static으로 내부적으로 생성되어 있는 Object[] 로만 생성 : 메모리를 사용하지 않기 위함
        - add()를 실행할 경우 size가 크다면 grow()를 통해 resize를 진행, 새로운 사이즈는 기존 크기의 1.5배, 최초로 할 경우는 default 값이 10으로 크기 설정
        - size()의 경우 내부적으로 int size 값으로 관리하고 있어 object의 길이만큼을 반환하지 않고 size 값으로 반환함
        - Object[]의 일급 컬렉션과 같은 느낌
    - LinkedList 기본 구조
        - 조회가 연결된 부분을 모두 탐색해야 되어 느리다. 삽입/삭제가 해당 부분에 다음 링크로 넣기만 하면 돼서 빠르다.
        - 연결된 node 구조로 리스트가 아닌 first, last, size 값만을 가진 class를 만든다.
        - node가 추가되면 new Node<>(last 노드, 새로운 값, null)를 통해 노드를 추가하고 last에 새롭게 생성된 node를 넣어준다. 기존 값이 null인 경우 first에도 해당 node를 넣어준다.
        - node가 기존에 값이 존재했다면 new Node<>()를 통해 노드를 추가하고 last 노드의 next 값으로 넣어준다. 이렇게 계속 연결해 나간다.
    ```java
    private static class Node<E> {
       E item;
       Node<E> next;
       Node<E> prev;
    
       Node(Node<E> prev, E element, Node<E> next) {
           this.item = element;
           this.next = next;
           this.prev = prev;
       }
    }
    ```
5. DB 최적화
    - 인덱싱 (인덱싱 순서로 =, 정렬 순서, 범위, 카디널리티로 처리)
    - 정규화 (통계를 위한 통계 디비로 정규화 작업, 데이터가 너무 많이 쌓여 연도별 테이블 정규화 작업)
    - explain 명령어를 통해 확인
6. spring 구조
    - request 흐름
        - request -> dispatcher servlet -> handler mapping 확인 -> handler adapter에서 controller 호출 -> contoller 데이터 반환 -> view resolver / message converter 데이터 반환
    - bean/component 등록
        - @Bean or @Component 사용하여 등록 -> @ComponentScan을 통해 프로젝트를 스캔 -> ApplicationContext에 등록 -> 필요 부분에 자동 주입
7. filter, aop, interceptor
    - filter
      - 클라이언트에서 요청을 보낼때 서버쪽에서 가장 먼저 동작
      - 인증 필터로 사용
    - interceptor
      - 컨트롤러에 진입하기 직전에 동작
      - 권한 체크로 사용
    - aop
      - 메서드의 동작 전/후로 작동
      - 메서드 로그로 사용
8. Transaction
   - 트랜잭션 격리 수준
     - 격리 수준에 따라 phantom read, non-repeatable read, dirty read 증상이 발생할 수 있다.
     - 격리 수준은 SERIALIZABLE(가장 엄격), REPEATABLE_READ(phantom read), READ_COMMITED(a+non-repeatable read), READ_UNCOMMITED(a+b+dirty read) 가 존재한다.
     - spring의 기본 격리 수준은 READ_COMMITED 이다.
   - 트랜잭션 전파 수준
     - REQUIRED(default), SUPPORTS, MANDATORY, REQUIRES_NEW, NOT_SUPPORTED, NEVER, NESTED가 있다.
     - `REQUIRED` 시작 트랜잭션이 있다면 모두 부모 트랜잭션으로 참여하게 만들고 없다면 새롭게 만든다.
     - `SUPPORTS` 이미 시작된 트랜잭션이 있다면 참여하고 없다면 없이 진행한다.
     - `MANDATORY` 이미 시작된 트랜잭션이 있다면 참여하고 없다면 예외가 발생한다.
     - `REQUIRES_NEW` 이미 진행중인 트랜잭션이 있다면 이를 보류시키고, 새로운 트랜잭션을 사용한다.
     - `NOT_SUPPORTED` 이미 진행 중인 트랜잭션이 있다면 이를 보류시키고, 트랜잭션을 사용하지 않고 진행한다.
     - `NEVER` 이미 진행중인 트랜잭션이 있다면 예외가 발생한다.
     - `NESTED` 이미 진행중인 트랜잭션이 있다면 자식 트랜잭션을 시작한다. 트랜잭션 안에 다시 트랜잭션을 만드는 것으로 자신의 커밋과 롤백은 부모에게 영향을 주지 않는다.
9. Secure Coding
   - 접근 권한
     - 유저 권한에 따른 접근 방지
     - IP를 통한 접근 방지
     - 파일 업로드시 확장자, 용량 검사를 통한 파일 처리
   - 입력값 유효성 검사
     - @Valid를 통해 입력값을 자동으로 확인하도록 처리
   - 개인정보
     - 개인정보 포함된 로그 출력시 마스킹 처리
     - 개인정보 데이터는 실제 디비에 암호화를 통한 저장 - 불러올땐 복호화
     - 디비에서 조회시 조회용 DB에서는 개인정보는 아예 저장하지 않음
     - 개인정보가 포함된 파일 전송시 파일 암호 필수
     - 외부에 데이터 전달시 암호환된 파일 이메일 전송 + 암호는 문자로 전송을 통한 2중 암호 체계
10. Critical Section and Race Condition (임계영역과 경쟁 조건)
    - 임계 영역이란 2개 이상의 프로세스 or 스레드가 동시에 접근할 때 결과가 달라질 수 있는 부분을 의미한다.
    - 경쟁 조건이란 2개 이상의 프로세스 or 스레드가 동시에 접근할 때 접근 순서에 따라 결과가 달라질 수 있는 상황을 말한다.
    - 해결 방법
      - `Mutex` 일반적인 lock을 걸어두고 lock이 해제되면 사용 가능하도록 처리하는 방법
      - `Semaphore` 여러 프로세스가 동시에 접근할 수 있는 대기열을 정해두고 사용하는 방법
        - 예를 들어 동시에 10명이 접근 가능한 페이지가 있다고 한다면 10명이 모두 접근할때까진 접근 가능, 단 10명이 모두 차면 접근 불가 
     
## 🟠 안랩 제품 확인
1. V3, 자녀안심 프로그램 등 개인 프로그램
2. EDR, EPP, APT 등 기업에서 보안 시스템 제공
3. 주요 고객층은 대기업, 중소기업, 공공기관 등 보안이 필요한 모든 부분에 고객층 존재

## 🟠 요즘 관심있는 분야
1. AI 분야가 관심을 갖고 보고 있다.
    - llm부터 시작해서 mcp와 agent까지 그리고 cli까지 계속해서 발전해가는 ai 분야
    - 최근 이슈로는 제미나이 cli가 재미있는 이슈였던거 같다. 기존에 클로드 desktop이 있었지만 유료로 사용 가능했던 분야라 쉽게 접근이 어려웠는데 제미나이로 인해 쉽게 접근이 가능해진것 같다.
    - ollama를 사용하여 로컬에 제미나이를 띄워서 프로젝트도 진행해보려고 했었다. ai 사용비 없이 로컬에서 기술 유출 걱정없이 사용할 수 있기에 재미있는 과정이였다.
2. DDD 관심을 갖고 있다.
    - 아직은 잘 모르고 겉핥기만 하고 있는 것 같다.
    - 더 자세히 공부하기 위해 토비님의 클린 스프링을 결제했고 수강중에 있다. 다 보고 최범균님의 도메인 주도 개발 시작하기 책을 보려고 한다.

## 🟠 요즘 개발 트렌드가 어떤것 같은가?
1. AI 분야가 확실히 관심도가 높은것 같다. 스타트업도 대부분 AI나 블록체인 쪽과 같이 업체들이 많아지고 있는것 같다.
2. 문제해결을 잘하는 하드 스킬이 좋은 개발자보다 커뮤니케이션이 잘되는 소프트 스킬이 좋은 개발자가 인정을 받기 시작한것 같다.
   - 그 부분에는 AI라는 부분과 개발자들의 실력이 전체적으로 크게 올라간 것도 한몫을 하는 것 같다.
   - 예전에는 한명이 캐리해서 모든 개발을 이끌었다면 현재는 팀원들과 조화롭게 진행되는 개발자를 더욱 원하는 것 같다.
   - 개발의 영역의 비지니스 로직이 더욱 복잡해짐에 따라 한명의 잘하는 개발자보다 서로 잘 이해하는 팀으로서 개발자들을 원하는것 같다.

## 🟠 마지막 할말 or 궁금한 점
1. 프레임워크가 되게 다양하던데 기존 시스템을 리팩토링하고 있는 걸까요?
    - trusts2 -> spring boot
    - jquery -> vue or next
2. 프래그래밍 언어는 kotlin과 typescript 인가요?
3. 개발툴은 어떤걸 사용할 수 있고 AI툴도 도입하고 있는지?