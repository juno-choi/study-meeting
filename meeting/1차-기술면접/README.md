# 🔴 준비

## 🟠 기본 면접 (회사별)

### 🟢 자기소개

```text
안녕하세요, 6년 차 백엔드 개발자 최준호입니다.

저는 코드블럭(PG사)에서 개발 커리어를 시작해 현재는 카카오VX에서 재직 중입니다. 
골프장 ERP 연동 시스템, 골프 예약 시스템, 관리자툴 개선 등 다양한 프로젝트를 수행하며
레거시 개선, 성능 최적화, 트러블슈팅, 협업 경험을 쌓아왔습니다.


```

### 🟢 지원 동기

```text
```

## 🟠 기본 면접

### 🟢 이직 사유

```text
최근 회사가 구조조정과 희망퇴직을 반복하면서 프로젝트가 무기한 보류되거나 중단되는 경우가 많아졌습니다. 
특히 제가 담당하던 핵심 프로젝트들도 인력 이탈로 인해 더 이상 진행이 어려워졌고, 안정적인 개발 환경에서 성장하고 싶다는 생각이 강해져 이직을 결심하게 되었습니다.
```

### 🟢 학점이 낮은 사유

```text
대학교 재학시 가정형편이 어려워져 생활비를 부담해야했고 고등학교 졸업부터 취업전까지 알바를 병행해야 했습니다.
그로인해 학점 관리에 아쉬움은 있었지만, 정보처리기사 자격증 취득, 부트캠프 과정 수료를 통해 부족한 부분을 채우려 노력하였습니다.
```

## 🟠 기술 면접

### 🟢 가장 의미있는 프로젝트

```text
골프장 ERP 연동 시스템이 가장 의미 있는 프로젝트입니다.
그 이유로는 해당 시스템의 주 담당자이기도 했고 레거시를 개선, OOM 문제를 해결한 경험이 있기 때문입니다.
```

### 🟢 협업한 경험

```text
셔틀버스 API 개발이 협업한 경험이라 할수 있을것 같습니다.
당시에 팀장님과 제가 한팀이 되어 진행했었고 사실 팀장님은 팀 관리와 다른 업무로 바빠 백엔드쪽은 제가 주로 리딩하며 진행했기 때문입니다.
기획, 디자인, 사업, 앱팀과 협업을 진행했고 보안 문제로 보안팀과도 협업을 진행하게 되었습니다.
```

### 🟢 리딩한 경험

```text
셔틀버스 API 개발이 리딩한 경험이라 할수 있을것 같습니다.
당시에 팀장님과 제가 한팀이 되어 진행했었고 사실 팀장님은 팀 관리와 다른 업무로 바빠 백엔드쪽은 제가 주로 리딩하며 진행했기 때문입니다.
기획, 디자인, 사업, 앱팀과 협업을 진행했고 보안 문제로 보안팀과도 협업을 진행하게 되었습니다.
```

### 🟢 개발자들을 리딩한 경험

```text
ERP 연동 시스템을 진행한 것이 개발자들을 리딩한 경험이라 할수 있을 것 같습니다.
해당 프로젝트는 저를 포함해 3명의 개발자가 함께 담당했던 프로젝트였는데요. 연차로는 제가 제일 적었지만 도메인에 대한 이해도가 가장 높았기에 해당 프로젝트의 리더 역할을 맡았습니다.
해당 프로젝트를 통해 깃 규칙을 정하여 진행하고 문제가 발생하거나 새로운 코드가 적용되어질 때 다같이 회의실에서 리뷰를 하는 등 자유롭게 내용을 공유할 수 있도록 진행하였습니다.
```

### 🟢 갈등 경험 (상사)

```text
상사와의 갈등은 하드코딩 이슈로 갈등이 있었습니다.
하지만 서비스의 형태와 회사의 방향성에 맞게 우선은 서비스를 위한 코드를 작성하고 이후 리팩토링이 되기 쉽도록 짜기 위해 노력하였습니다.
예를 들어 하드코딩의 경우 하드코딩 패턴에 따라 class로 분리하여 작성하도록 했고 이후에 주석과 기간 조건들을 필수로 입력하도록 하여 기간이 종료되었을 때 코드를 삭제할 수 있도록 하였습니다.
```

### 🟢 갈등 경험 (팀원)

```text
docker, jenkins를 도입하며 팀원들과의 의견을 주고받은 경험이 있습니다.
당시 팀원들은 저보다 리눅스 활용 능력이 뛰어났기 때문에 현재 배포 프로세스에 대해 불만이 없었습니다.
오히려 docker와 jenkins의 도입은 팀원들에게 부담이라는 의견이 있었는데요.
이 부분을 해결하기 위해 팀원들에게 혹시라도 문제가 발생한다면 제가 직접 가서 도와주고 같이 문제를 해결해줄 수 있다고 했고
팀원들을 위한 교육 시간도 마련하기로 하였습니다. 대표님과 팀장님에게는 문서와 실습 과정을 직접 시연하여 현재 배포가 1시간이 걸리는 것에 비해
새로운 인원이 투입된다 하여도 5분안에 배포가 가능하고 jenkins의 동작도 기존 리눅스 명령어를 그대로 사용함으로써 현재 인원들도 금방 적응할 수 있도록 적용할 수 있다는 것을 보였습니다.
그 결과 대표님과 팀장님의 승인으로 회의시간을 따로 잡아주셔서 팀원들에게 시연과 교육을 진행하였고 실제로 제가 퇴사 이후에도 현재도 도커와 jenkins를 통해 잘 배포하고 있다고 들었습니다.
```

### 🟢 객체지향적으로 설계해본 경험

```text
ERP 연동 시스템 프로젝트가 가장 객체지향적으로 설계해본 경험이라고 생각합니다.
그 이유로는 우선 역할별로 class를 나누어 적용하였기 때문인데요. 각자의 역할을 나누어 적용하였고
interface를 통해 class를 분리하여 적용할 수 있도록 적용하였기에 이 또한 객체지향적으로 설계한 경험이라 할 수 있습니다.
```

### 🟢 시스템 구성도 그려보기

```text
화이트보드로 그리기!
```

---

## 🟠 컬처핏

### 🟢 요즘 관심있는 분야
```text
AI 분야쪽이 관심이 있습니다. AI 로직을 분석한다기 보다 어떻게 하면 개발에서 AI를 활용하여 생산성을 증대시킬 수 있을지 관심이 있습니다.
제미나이 cli나 커서 툴과 같은 ai 툴을 통해 분석과 문제 해결 시간을 줄인다던지
ollama를 통해 로컬에 ai를 설치하여 개인 ai api를 만들어보는 등 ai를 활용하는 방법에 대해 관심이 있습니다.
```

### 🟢 요즘 개발 트렌드가 어떤것 같은가?
```text
AI가 가장 핫한 트렌드로 보입니다. 스타트업도 대부분 AI를 활용하는 업체들이 주로 등장하고 있고
테크 기업들에서도 AI를 활용하여 생산성에 기여하려는 움직임이 눈에 띄게 보이는 것 같습니다.
```

### 🟢 그런 트렌드를 쫓기 위해 하고 있는 방법이 있나요?

```text
AI 분야는 아직 발전중인 분야고 아직 누가 전문가다. 누가 맞다고 할수 없는 분야 같습니다.
그래서 최대한 최신 트렌드를 알기 위해 geek news나 개발 커뮤니티에 많은 정보를 얻으려고 하고 있습니다.
그 외에도 개인 프로젝트들을 통해 직접 사용해보기도 합니다.
```

### 🟢 마지막 할말 or 궁금한 점

```text
좋은 개발자란 어떤 개발자일까요?


```

### 🟢 좋은 개발자란?

```text
도메인에 대한 이해도가 높은 개발자
끊임 없이 자기개발을 하는 개발자
오너십을 갖고 문제를 해결해갈 수 있는 개발자
정상 시스템을 개선할 용기가 있는 개발자
자신의 지식을 나눌 수 있는 개발자
```

### 🟢 열심히 노력해본 경험

```text
미라클 모닝을 해본 경험이 있다.
개발자로서 더 성장하고 싶었고 회사에서의 실무 경험으로는 많이 부족하다고 느꼈습니다.
더욱 성장하기 위해 출근 전 시간을 활용하여 인강과 개인프로젝트를 진행하였었고
그 내용들을 블로그에 정리해두기도 하였었습니다.
그 결과로 구글에 java17을 검색하면 공식 사이트 외에 제가 올려둔 글이 가장 상단에 노출되기도 하였습니다.
```

### 🟢 깃 잔디를 중간에 비어있는 부분이 있는데? or 현재는 블로그 글이 없는거 같은데?

```text
회사 이직 후 제가 가고 싶었던 기업이였기에 회사 업무에 집중하고 회사에 기여하는데 집중하며 개인의 활동은 잠시 쉬었습니다.
실무에서도 많은 것을 배우고 경험하였습니다. 최근에는 다시 트렌드를 쫓기 위해 인강과 깃 잔디 심기를 다시 진행하고 있습니다.
```

---

## 🟠 기본 cs

### 🟢 JVM
- class loader, runtime data area, execution engine으로 구성
- class loader는 class를 실제 실행하기 위한 코드로 읽어오고 jvm에 배치해주는 역할
- runtime data area는 jvm의 메모리 영역
- execution engine은 실제 코드를 한줄씩 실행하는 interpreter와 병렬 실행하는 jit compiler, gc로 구성
- runtime data area는 method area, heap area, stack area, native area, pc register로 구성
- method에서는 static, method 등 프로그램이 실행할때 생성되고 명시적으로 null로 처리할때까지 살아있는 모든 쓰레드들이 공유하는 객체들이 존재
- heap은 new 객체로 생성된 객체들이 존재
- stack은 메서드의 실행 순서와 메서드 내 필드들이 임시로 저장되는 공간
- native area는 java에서 os의 기능 실행하기 위한 공간
- pc register는 각 스레드가 어떤 명령어를 실행중인지 명령어 주소 저장 공간

### 🟢 GC
- young, old 영역
- young은 eden(최초 생성), survive0, survive1 영역으로 나누어서 구분됨
- GC의 종류는 young을 지우는 Minor GC, old를 지우는 Major GC로 구분됨
- 영역 메모리가 가득 차면 영역 메모리 gc
- 메모리가 gc에 오랫동안 걸리지 않아 old가 계속 차게 되면 메모리 사용량 증가
- gc가 자주 발생하면 응답 지연 발생 가능성이 높다 (stop the world)
- 기본 gc 알고리즘은 G1으로 설정되어 있음
- GC 튜닝은 정말 최후 최후의 방법임. 코드레벨에서 먼저 개선할 것

### 🟢 hash 구조
- 해시 function
- 입력 받은 데이터를 해시 값으로 변환
- 해시 테이블
    - 변환 된 값을 key로 key-value 형태로 저장하는 테이블
- 해싱
    - 키값을 해시 함수를 통해 해시 테이블로 저장하는 과정
- 해시 충돌
    - 해시 값을 만들었을때 중복되는 경우를 해시 충돌이라 한다.
    - 충돌 해결로는 open address 또는 chaning 기법이 있고 java는 chaning 기법을 사용한다.
    - linked list 형태로 충돌되는 데이터를 저장하다가 특정 조건 이상 충돌이 발생하면 트리 구조로 변경한다.
        - java의 특정 조건은 맵의 총 크기가 64 이상이고 해당 충돌값이 8개 이상인 경우 트리로 변경한다.
        - 만약 맵 총 크기가 64 미만이고 충돌이 8번 이상 발생한 경우는 resize()를 통해 해시를 재생성하여 해시테이블을 새롭게 만들어 정렬한다.
    - 데이터가 많은 경우 트리구조로 변경되어 읽기시 최대 O(n) 복잡도가 걸릴 수 있는 부분은 O(log n)으로 줄이기 위함니다.

### 🟢  list 구조
- ArrayList 기본 구조
    - 조회가 빠르다. 삽입/삭제시 재생성해야 되므로 느리다.
    - 최초 생성시 static으로 내부적으로 생성되어 있는 Object[] 로만 생성 : 메모리를 사용하지 않기 위함
    - add()를 실행할 경우 size가 크다면 grow()를 통해 resize를 진행, 새로운 사이즈는 기존 크기의 1.5배, 최초로 할 경우는 default 값이 10으로 크기 설정
    - size()의 경우 내부적으로 int size 값으로 관리하고 있어 object의 길이만큼을 반환하지 않고 size 값으로 반환함
    - Object[]의 일급 컬렉션과 같은 느낌
- LinkedList 기본 구조
    - 조회가 연결된 부분을 모두 탐색해야 되어 느리다. 삽입/삭제가 해당 부분에 다음 링크로 넣기만 하면 돼서 빠르다.
    - 연결된 node 구조로 리스트가 아닌 first, last, size 값만을 가진 class를 만든다.
    - node가 추가되면 new Node<>(last 노드, 새로운 값, null)를 통해 노드를 추가하고 last에 새롭게 생성된 node를 넣어준다. 기존 값이 null인 경우 first에도 해당 node를 넣어준다.
    - node가 기존에 값이 존재했다면 new Node<>()를 통해 노드를 추가하고 last 노드의 next 값으로 넣어준다. 이렇게 계속 연결해 나간다.
```java
private static class Node<E> {
   E item;
   Node<E> next;
   Node<E> prev;

   Node(Node<E> prev, E element, Node<E> next) {
       this.item = element;
       this.next = next;
       this.prev = prev;
   }
}
```

### 🟢 DB 최적화
- 인덱싱 (인덱싱 순서로 =, 정렬 순서, 범위, 카디널리티로 처리)
- 정규화 (통계를 위한 통계 디비로 정규화 작업, 데이터가 너무 많이 쌓여 연도별 테이블 정규화 작업)
- explain 명령어를 통해 확인

### 🟢 spring 구조
- request 흐름
    - request -> dispatcher servlet -> handler mapping 확인 -> handler adapter에서 controller 호출 -> contoller 데이터 반환 -> view resolver / message converter 데이터 반환
- bean/component 등록
    - @Bean or @Component 사용하여 등록 -> @ComponentScan을 통해 프로젝트를 스캔 -> ApplicationContext에 등록 -> 필요 부분에 자동 주입

### 🟢 filter, aop, interceptor
- filter
    - 클라이언트에서 요청을 보낼때 서버쪽에서 가장 먼저 동작
    - 인증 필터로 사용
- interceptor
    - 컨트롤러에 진입하기 직전에 동작
    - 권한 체크로 사용
- aop
    - 메서드의 동작 전/후로 작동
    - 메서드 로그로 사용

### 🟢 Transaction
- 트랜잭션 격리 수준
    - 격리 수준에 따라 phantom read, non-repeatable read, dirty read 증상이 발생할 수 있다.
    - 격리 수준은 SERIALIZABLE(가장 엄격), REPEATABLE_READ(phantom read), READ_COMMITED(a+non-repeatable read), READ_UNCOMMITED(a+b+dirty read) 가 존재한다.
    - spring의 기본 격리 수준은 READ_COMMITED 이다.
- 트랜잭션 전파 수준
    - REQUIRED, SUPPORTS, MANDATORY, REQUIRES_NEW, NOT_SUPPORTED, NEVER, NESTED가 있다.
    - `REQUIRED(default)` 시작 트랜잭션이 있다면 모두 부모 트랜잭션으로 참여하게 만들고 없다면 새롭게 만든다.
    - `SUPPORTS` 이미 시작된 트랜잭션이 있다면 참여하고 없다면 없이 진행한다.
    - `MANDATORY` 이미 시작된 트랜잭션이 있다면 참여하고 없다면 예외가 발생한다.
    - `REQUIRES_NEW` 이미 진행중인 트랜잭션이 있다면 이를 보류시키고, 새로운 트랜잭션을 사용한다.
    - `NOT_SUPPORTED` 이미 진행 중인 트랜잭션이 있다면 이를 보류시키고, 트랜잭션을 사용하지 않고 진행한다.
    - `NEVER` 이미 진행중인 트랜잭션이 있다면 예외가 발생한다.
    - `NESTED` 이미 진행중인 트랜잭션이 있다면 자식 트랜잭션을 시작한다. 트랜잭션 안에 다시 트랜잭션을 만드는 것으로 자신의 커밋과 롤백은 부모에게 영향을 주지 않는다.

### 🟢 Secure Coding
- 접근 권한
    - 유저 권한에 따른 접근 방지
    - IP를 통한 접근 방지
    - 파일 업로드시 확장자, 용량 검사를 통한 파일 처리
- 입력값 유효성 검사
    - @Valid를 통해 입력값을 자동으로 확인하도록 처리
- 개인정보
    - 개인정보 포함된 로그 출력시 마스킹 처리
    - 개인정보 데이터는 실제 디비에 암호화를 통한 저장 - 불러올땐 복호화
    - 디비에서 조회시 조회용 DB에서는 개인정보는 아예 저장하지 않음
    - 개인정보가 포함된 파일 전송시 파일 암호 필수
    - 외부에 데이터 전달시 암호환된 파일 이메일 전송 + 암호는 문자로 전송을 통한 2중 암호 체계

### 🟢  Critical Section and Race Condition (임계영역과 경쟁 조건)
- 임계 영역이란 2개 이상의 프로세스 or 스레드가 동시에 접근할 때 결과가 달라질 수 있는 부분을 의미한다.
- 경쟁 조건이란 2개 이상의 프로세스 or 스레드가 동시에 접근할 때 접근 순서에 따라 결과가 달라질 수 있는 상황을 말한다.
- 해결 방법
    - `Mutex` 일반적인 lock을 걸어두고 lock이 해제되면 사용 가능하도록 처리하는 방법
    - `Semaphore` 여러 프로세스가 동시에 접근할 수 있는 대기열을 정해두고 사용하는 방법
        - 예를 들어 동시에 10명이 접근 가능한 페이지가 있다고 한다면 10명이 모두 접근할때까진 접근 가능, 단 10명이 모두 차면 접근 불가

### 🟢 트리 자료구조
- 구조
  ```java
  class TreeNode {
    int value;
    TreeNode left;
    TreeNode right;  // 이진 트리의 경우
  }
  ```
- linkedList 구조와 매우 유사하지만 더 유연한 구조
- 루트, 리프 노드로 구성되어 있다.

### 🟢 B-tree
- DB에서 인덱스를 효율적으로 관리하기 위한 트리구조 기반 자료구조
- 이진 트리가 아닌 다진 트리 구조

### 🟢 B+tree
- 실제 DB에 많이 사용됨
- B-tree와의 차이점은 모든 실제 데이터는 가장 마지막줄인 리프노드에 저장됨

### 🟢 B-tree와 B+tree의 차이점
[B-tree와 B+tree 구조의 차이](https://velog.io/@juhyeon1114/MySQL-Index%EC%9D%98-%EA%B5%AC%EC%A1%B0-B-Tree-BTree)
- 만약 10~50 범위를 탐색한다고 했을 경우
  - B-tree의 탐색 방법
    - 루트에서 10을 찾음 10이상 40이하 데이터 검색, 루트에서 40을 찾음 40이상 50이하 데이터 검색 총 2번의 선형 탐색이 발생
  - B+tree의 탐색 방법
    - 10 or 50의 위치를 탐색, 10을 먼저 찾았다면 10부터 50까지 연결된 노드를 통해 50까지 다음 노드를 계속해서 탐색
- B-tree와 B+tree 효율 
  - 탐색 측면에서는 B+tree가 범위 검색에선 훨씬 효율적
  - 삽입, 삭제, 수정, 생성시 B+tree는 노드간의 연결 데이터가 추가로 필요해짐, 메모리 측면과 데이터 변경 측면에서는 B-tree가 효율적
  - 하지만 DB의 대부분은 select의 효율을 중요시 하기에 B+tree를 주로 사용하게 됨

### 🟢 join
- inner join
  - join
  - 왼쪽 데이터 기준 오른쪽 데이터 조건이 부합한다면 노출 이 외에는 노출되지 않음
- left outer join
  - left join
  - 왼쪽 데이터 기준 오른쪽 데이터 조건이 부합한다면 노출 그렇지 않다면 null로 노출
- right outer join
  - right join
  - 오른쪽 데이터 기주능로 왼쪽 데이터 조건이 부합한다면 노출 그렇지 않다면 null로 노출
- full outer join
  - union
  
### 🟢 데이터 정합성을 지키기 위한 방법

- DB 차원에서의 정합성 유지
  - `제약조건` 설정(unique, not null, key 설정)으로 잘못된 입력을 방지
  - `트랜잭션`을 통해 작업 단위를 묶어 원자성 보장
  - `트리거`를 통해 데이터 변경시 로그 or 관련 데이터 변경 처리를 통해 데이터 동기화
  - `락` 동시성 제어를 통해 데이터 충돌 방지
- Application 차원의 정합성 유지
  - `Validation`을 통해 잘못된 입력 방지
  - `락` 동시성 제어를 중복 요청 방지
  - `데이터 변조 방지` 서버에서만 사용되고 클라이언트는 사용하지 않는 데이터는 클라이언트 쪽으로 아예 전송하지 않도록 설계
  - `이벤트 순서 제어` 같은 요청이 여러번 오더라도 Idempotent(멱등성)을 통해 항상 같은 결과가 노출되도록 설계
    - 고유 요청 id 값이나 상태값을 통해 1번 처리된 값은 2~3번 요청이 더 오더라도 무시되도록 처리(이미 결제가 완료된 결제건입니다)
- 분산 환경 차원의 정합성 유지
  - `락` Redis or DB lock을 통해 데이터 충돌 방지
  - `버전 관리` 업데이트시 버전 값을 통해 충돌 발지
  - `서킷 브레이커 / 재시도 전략` 외부 API 실패시 재요청, 재요청시 카운트를 통해 상태로 관리, 이후 배치를 통해 상태를 다시 체크하는 전략
  - `Saga 패턴` MSA 환경에서 보상 로직 처리를 통해 정합성 유지
    - 결제 실패 -> 결제 취소 로직 실행
  - `이벤트 소싱 + CQRS`
    - [Event Sourcing + CQRS](https://curiousjinan.tistory.com/entry/cqrs-explained-event-sourcing#%EC%9D%B4%EB%B2%A4%ED%8A%B8%20%EC%86%8C%EC%8B%B1%EA%B3%BC%20CQRS%20%EC%97%AD%EC%82%AC%EB%B6%80%ED%84%B0%20%EC%95%8C%EA%B3%A0%20%EB%84%98%EC%96%B4%EA%B0%91%EC%8B%9C%EB%8B%A4.-1) 개념 꼭 다시 봐보자!
