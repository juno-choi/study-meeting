`출처` [JAVA 언어로 배우는 디자인 패턴 입문 3판](https://www.yes24.com/product/goods/115576266)

# 🔴 디자인 패턴

디자인 패턴을 모두 정확하게 파악하기는 어렵지만 각 패턴마다 어떤 설계를 목표로 하는지에 대해 확인해두자.

## 🟠 디자인 패턴에 익숙해지다

### 🟢 Iterator

```
컬렉션 내부 구조에 상관없이 요소들을 순차적으로 접근할 수 있도록 한다.
```

반복된 처리를 위해서는 for, forEach, while 같이 여러 반복 방법이 존재한다. 이를 하나의 통합된 디자인 패턴을 적용하는 방법이 Iterfator 패턴이다.

### 🟢 Adapter

```
사이에 끼워서 재사용한다.
```

프로그램에서 이미 제공된 데이터와 다른 프로그램에서 사용하기 위해 필요한 데이터 그 사이의 차이를 포장하여 사용하는 방법을 Adapter 패턴이라 한다.

## 🟠 하위 클래스에 맡기다

### 🟢 Template Method

```
상위 클래스에서 알고리즘의 골격(템플릿)을 정의하고, 일부 세부 처리를 하위 클래스가 구현하여 알고리즘을 완성한다.
```

상위 클래스에서 템플릿이 될 메서드가 추상적으로 정의되어 있고, 하위 클래스에서 해당 메서드들을 구현하여 처리합니다.

클래스에서 알 수 있는 것은 추상 메서드를 호출하여 사용하는 방법 뿐이며 상위 실제 구현은 하위 클래스에서 담당한다.

### 🟢 Factory Method

```
객체 생성 코드를 하위 클래스로 분리하여, 상위 클래스는 구체적인 클래스에 의존하지 않도록 만든다.
```

상위 클래스는 뼈대를 만들고, 하위 클래스에서는 구현하는 부분은 위에 설명한 Template Meathod와 동일하다. 이 부분을 인스턴스 생성에 적용한 것이 Factory Method이다.

## 🟠 인스턴스를 만들다

### 🟢 Singleton

```
클래스이 인스턴스를 하나의 프로그램에서 단 하나만 만들고 싶을 때
```

인스턴스가 하나만 존재하는 것을 보증하는 패턴을 Singleton이라고 한다.

### 🟢 Prototype

```
복사해서 인스턴스를 만든다
```

기존 객체를 복사(clone)해서 새로운 객체를 생성하는 패턴

복잡한 객체를 새로 생성하는 비용을 줄이고, 객체의 상태를 그대로 유지한 복제본을 생성할 수 있다.

### 🟢 Builder

```
복잡한 인스턴스를 조립하여 사용한다
```

뼈대를 먼저 만들고 각각 부분을 조립하여 단계적으로 만들어 가는 패턴을 Builder 패턴이라고 한다.

### 🟢 Abstract Factory

```
관련 부품을 조합하여 제품을 만든다
```

추상 공장을 통해 추상적인 부품들을 조합하여 각각의 하위 클래스에서 구체적인 구현을 한다.

## 🟠 나누어 생각하다

### 🟢 Bridge

```
기능 계층과 구현 계층을 나눈다
```

기능 계층(Abstraction)과 구현 계층(Implementation)을 분리하여 독립적으로 확장할 수 있도록 하는 패턴

예를 들어, UI의 버튼이 윈도우용과 리눅스용 구현이 다르더라도 추상적인 버튼 인터페이스로 동일하게 다룰 수 있다.

### 🟢 Stratey

```
전략에 따라 알고리즘이 변경된다
```

문제를 해결하기 위한 방법에 따라 알고리즘을 전략적으로 그때 그때 교체하여 사용한다.

## 🟠 동일시하다

### 🟢 Composite

```
그릇과 내용물을 동일시한다
```

디렉터리와 파일을 하나의 종류로 취급하면 디렉터리 안에 파일을 넣듯이 디렉터리도 넣을 수 있게 된다.

이와 같이 그릇과 내용물을 같은 종류로 취급하면 유리한 구조가 있는데 그릇 안에 그릇을 넣는 재귀적 구조로 만드는 것을 Composite 패턴이라 한다.

### 🟢 Decorator

```
기존 객체에 추가 기능을 동적으로 부여할 수 있게 하는 패턴
```

객체를 중심으로 점점 자식을 더해 가는 디자인 패턴을 Decorator 패턴이라 한다.

## 🟠 데이터 구조를 돌아다니다

### 🟢 Visitor

```
데이터 구조를 돌아다니면서 처리한다
```

데이터 구조와 처리를 분리하여, 새로운 연산을 추가할 때 기존 구조를 수정하지 않아도 되도록 하는 패턴

대표적으로 컴파일러의 문법 트리 처리 등에 사용된다.

### 🟢 Chain of Responsibility

```
책임을 떠넘긴다
```

여러 객체들을 사슬처럼 연쇄적으로 묶고, 객체 사슬을 차례대로 돌면서 원하는 객체를 결정하는 방법

## 🟠 단순화한다

### 🟢 Facade

```
단순한 창구를 만든다
```

복잡한 서비스 로직을 가리고 하나의 요청에 대한 응답으로 반환한다

### 🟢 Mediator

```
중재자를 통해 처리한다
```

모두 중재자에게 보고하고, 중재자가 판단하여 멤버에게 지시한다.

## 🟠 상태를 관리하다

### 🟢 Observer

```
상태 변화를 관찰하고 알려준다
```

관찰 대상의 상태가 변화한다면 관찰자들에게 내용을 전달한다

### 🟢 Memento

```
상태를 저장한다
```

텍스트 에디터를 사용할 때, 실행 취소를 진행해본 적이 있을 것이다. 이때 실행 취소를 구현하려면 인스턴스가 가진 정보를 저장해 두어야 하고 저장해둔 정보로 인스턴스를 원래 정보로 복구해야 한다.

이렇게 인스턴스를 상태에 따라 저장해두는 것을 Memento 패턴이라고 한다.

### 🟢 State

```
상태를 클래스로 표현한다
```

객체의 내부 상태에 따라 행위가 달라지는 상황에서, 상태를 객체로 만들어 캡슐화하고 행위를 위임하는 패턴이다.

상태 전환이 빈번한 경우에 유리하며, 코드의 조건문을 줄일 수 있다.

## 🟠 낭비를 없애다

### 🟢 Flyweight

```
같은 것은 공유해서 낭비를 없앤다
```

인스턴스가 필요할 때 항상 new를 통해 새롭게 만드는 것이 아닌, 이미 만들어진 인스턴스를 이용할 수 있다면 그것을 공유하여 사용하는 것인 Flyweight 패턴이다.

### 🟢 Proxy

```
필요해지면 만든다
```

해당 객체를 생성해서 진행하기에는 리소스가 너무 클때, 가벼운 대리인 객체를 대신 만들어 사용하다가 대리인이 할 수 있는 범위를 넘어서는 경우에는 본인 객체가 직접 생성되어 처리하도록 처리하는 방법

## 🟠 클래스로 표현하다

### 🟢 Command

```
요청을 객체(명령)로 캡슐화하여, 요청을 큐에 저장하거나 취소할 수 있게 한다.
```

사건(=event)를 클래스로 처리하여 표현하는 방법이다.

예를 들어 클릭 이벤트에 대한 클래스를 만들어 두고 발생 순서에 따라 행동들이 클래스로 구현되어 있으면 해당 클래스들의 집합이 프로그램이 된다.

### 🟢 Interpreter

```
문법 규칙을 클래스로 표현한다
```

Interpreter 패턴은 어떤 언어의 문법을 클래스 구조로 표현하고, 해당 언어로 작성된 문장을 해석하는 해석기(인터프리터)를 구성하는 패턴이다.

계산기와 같은 시스템을 예로 들수 있다.

---

# 🔴 디자인 패턴의 실제 사용 예시

## 🟠 Spring에서 사용되는 패턴

### 🟢 Singleton

하나의 인스턴스만 생성해서 재사용

@Component, @Service 등 스프링 빈은 기본적으로 싱글톤 스코프

### 🟢  Factory Method

객체 생성을 서브클래스에 위임

BeanFactory, ApplicationContext가 Bean을 생성할 때 사용

### 🟢 Proxy
실제 객체 앞에 대리 객체를 두어 접근 제어, 로깅, 트랜잭션 처리

AOP (Aspect-Oriented Programming), @Transactional, @Async

### 🟢 Template Method
전체 알고리즘의 구조는 상위 클래스에서 정의하고, 세부 단계는 하위 클래스가 구현

JdbcTemplate, RestTemplate, TransactionTemplate 등에서 사용됨

### 🟢 Strategy

런타임에 알고리즘을 변경할 수 있도록 전략을 캡슐화

AuthenticationManager에서 인증 전략 사용, ResourceLoader, ViewResolver 등

### 🟢 Observer

상태 변경 시 등록된 리스너들에게 알림

ApplicationEventPublisher, @EventListener 구조

### 🟢 Builder
복잡한 객체를 단계적으로 생성

MockMvcBuilders, ResponseEntity.ok().body(), UriComponentsBuilder

## 🟠 실무에서 적용할 수 있는 패턴

### 🟢 Strategy
인터페이스를 기준으로 알고리즘/서비스 분기 처리 (e.g. PaymentService 전략 패턴으로 처리)

### 🟢 Factory Method	객

체 생성 책임 분리, if/switch 제거
### 🟢 Builder

생성자 파라미터가 많은 DTO/엔티티에 사용

### 🟢 Singleton

설정값, 캐시 객체 관리
### 🟢 Decorator

기능을 감싸면서 유연하게 확장 (e.g. 필터 체인)

### 🟢 Adapter

외부 API와 내부 모델 간의 데이터 포맷 변환

### 🟢 Facade

복잡한 로직을 하나의 인터페이스로 추상화 (e.g. 통합 서비스 계층)

### 🟢 Template Method

공통 흐름 정의 + 부분 동작은 오버라이드 (e.g. 인증 로직 등)