## 🟠 OOP

### 🟢 Why Clean Code

SW는 한번 작성되면 최소 10번은 읽힌다. 그래서 대충 돌아가게만 작성한다면 리소스가 낭비된다. 그렇기에 읽기 편하도록 작성해야 한다.

대부분의 소프웨어 엔지니어는 새로운 코드를 작성하는 업무보다 남이 작성한 코드를 읽고 유지보수 하는 일이 많을 것이다.

기계가 이해할 수 있는 코드는 아무나 작성할 수 있지만 인간이 이해할 수 있는 코드는 잘 훈련된 소프트웽 엔지니어만 작성할 수 있다.

### 🟢 Why OOP

데이터 기반으로 설계를 진행하면 데이터가 변경되었을 때 관련된 모든 부분이 수정되어야 한다.

객체지향으로 설계를 진행한다면 각자의 책임에 맡게 캡슐화(응집도가 높게)되어 작성되어야 하고 느슨한 결합(decoupling)으로 진행하기 위해 interface를 통해 작성할 수 있도록 한다.
그렇게 된다면 객체 단위로 수정이되어도 전체에 영향이 주지 않는다.

그런데 레거시 프로젝트들은 다 데이터 기반으로 설계하고 있을까? 그 이유는 그게 가장 쉽기 때문이다.

그럼 우리는 객체지향적인 설계로 프로젝트를 시작해야될까? 그건 되게 어려운 일이다. 객체지향적으로 사고하는것 자체가 어려운 일이기 때문에 그런 사고가 잘 되지 않는다면 어렵다.

그렇기 때문에 우리는 리팩토링을 해야한다. 데이터 기반으로 설계를 해서 빠르게 서비스하고 객체지향적으로 개선해가는 방향을 잡는 것이다.
그렇게 쉽게 하기 위해서는 테스트코드를 통해 기존 기능을 테스트해가면서 개선해가는 방향을 가질 수 있다.

여기서 또 팁으로 알아두자면 이벤트성 프로젝트는 데이터 기반으로 빠르게 서비스를 만들어서 제공하고 그 외에 계속해서 유지보수를 진행한다면 이후에 리팩토링을 진행해야 한다.
회사에서 진행하는 모든 프로젝트는 절대로 단순하지 않다. 그 이유는 이후 요구사항이 계속 변경되고 추가되면서 더욱 어려워지기 때문이다.

### 🟢 Object(객체) / Role(역할) / Responsibillity(책임)

게시글이라는 서비스를 만든다면 BoardController, BoardService 와 같이 코드를 작성할 것이다. 하지만 이것은 객체지향적으로 설계한 것이 아닌 데이터기반으로 본 것이다.

도메인 기준으로 본다면 WriteBoardController, WriteBoardService와 같이 class명이 작성되어야 한다는 것이다.

객체지향적 설계 과정
```
기능을 제공할 객체 후보 선별 -> 내부에서 필요한 데이터 선별 -> class diagram 그리기 -> 객체 간 메세지 흐름을 설계 -> sequence diagram
```

### 🟢 Encapsulation(캡슐화)

`Tell Don't Ask`
내부적으로 어떻게 구현되었는지를 감춰 외부에 영향을 주지 않도록 한다.

```java
if (member.getExpiredDate().getTime() < System.currentTimeMillis()) 
```
이러한 부분은 캡슐화를 통해

```java
if (member.isExpired()) 
```

이렇게 수정해서 사용이 가능하다.

### 🟢 Polymorphism(다형성)

java에서는 상속을 통해 다형성을 구현할 수 있다.

다형성을 통해 재사용이 가능해지는데 재사용성이란 super class를 child class가 상속하여 재사용하는 것은 틀린 말이다. 나중에 수정하기가 더 어렵다.

interface를 통해 여러 구현체를 사용해서 적용할 수 있다.

interface를 적용하면 테스트가 쉽다.

interface를 적용하면 decorator 패턴을 적용하기 쉽다.

interface를 사용하면 코드를 재사용하기 쉬워진다. 여기서 재사용은 interface를 통해 Car를 k3_2024를 구현했다가 k3_2025를 새롭게 구현했을 때 기존 로직에는 여향이 없이 k3_2025로 갈아 끼워주면 해당 코드를 재사용할 수 있다는 의미이다.

### 🟢 Composition(delegation)

java의 특성상 문제를 풀어갈때 inheritance(상속)을 통해 문제를 해결하려고 하는 경우가 있다. 하지만 이 경우에는 강한 결합으로 인해 이후에 유지보수의 어려움이 생기게 된다.

문제를 풀어갈땐 상속을 하지 않고 Composition(delegation)컴포지션을 통해 문제를 해결한다면 느슨한 결합으로 이후 유지보수에 유리하다.

## 🟠 Function

### 🟢 원칙
1. 한가지 일만 해야 한다.

1. 함수의 크기는 한 화면에 들어와야 한다. `현재와는 맞지 않음!`
    1. 80년대 터미널의 한 화면은 24줄, 80 컬럼
    1. 현재는 큰 모니터와 다중 모니터로 인해 100줄, 150컬럼 늘어남
    1. indentation, while, nested, if 등은 없이 작성할 수 있도록 해야한다.
    1. 그 결과로 잘 지어진 서술적인 긴 이름을 갖는 범위가 작고 많은 함수를 갖게 된다.

### 🟢 The First Rule of Functions
1. 함수는 더 이상 작아질 수 없을 만큼 작아야 한다.
    1. 큰 함수를 보면 class로 추출할 생각을 해야함. (Extract Method Object)
    1. class는 일련의 변수들에 동작하는 기능의 집합
