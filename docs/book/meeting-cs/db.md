# 🔴 데이터베이스

데이터베이스는 일정한 규칙 혹은 규약을 통해 구조화되어 저장되는 데이터 모음이다.

`엔티티` 엔티티는 사람, 장소, 물건, 사건, 개념 등 여러개의 속성을 지닌 명사를 의미한다.

`릴레이션` 데이터베이스에서 정보를 구분하여 저장하는 기본 단위입니다. 릴레이션은 테이블이라고 생각하면 된다.

`속성` 속성은 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보입니다.

`도메인` 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합을 말한다.

## 🟠 필드와 레코드

필드는 DB에서 컬럼이라고 생각하면 된다. 레코드는 테이블에 row라고 생각하면 된다.

## 🟠 관계

데이터베이스에는 여러 테이블이 존재한다.여러 테이블들은 서로의 관계가 정의된다.

### 🟢 1:1 관계

예를 들어 유저와 이메일은 한개씩 있을 것이다. 이런 경우가 1:1이다.

### 🟢 1:N 관계

예를 들어 쇼핑몰에 데이터를 만든다고 할때 유저와 주문 상품에 대해 생각해보자. 유저는 1명이고 주문 테이블에는 해당 유저가 여러 주문을 만들 수 있다. 이럴때 1:N의 관계이다.

### 🟢 N:M 관계

회원의 메뉴 권한을 정의하는 테이블을 만들때 권한에 따른 메뉴는 N:M의 관계이다. 권한은 여러 메뉴를 가질 수 있고 메뉴에서도 여러 권한을 가질 수 있는 관계가 형성된다. 이를 해결하기 위해 중간 Mapping Table을 생성하여 권한-메뉴_권환-메뉴 와 같이 테이블을 구성할 수 있다. 이렇게 된다면 1:N, M:1 관계가 형성된다.

## 🟠 키

테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치로 기본키, 외래키, 후보키, 슈퍼키, 대체키가 있다.

### 🟢 Primary Key

기본키는 유일성과 최소성을 만족하는 키다. 테이블의 데이터 중 고유하게 존재하는 속성이다.

### 🟢 Foreign Key

외래키는 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와 관계를 식별하는데 사용됩니다.

### 🟢 Candidate Key

후보키는 기본키가 될 수 있는 후보들이다.

### 🟢 Alternate Key

대체키는 후보키가 두개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말한다.

### 🟢 Super Key

슈퍼키는 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키이다.

## 🟠 ERD와 정규화

### 🟢 ERD

ERD는 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할이다. 시스템의 요구 사항을 기반으로 작성되며 이 ERD를 기반으로 데이터베이스를 구축한다.

### 🟢 정규화

정규화 과정은 테이블(릴레이션)간 잘못된 종속 관계를 풀어가거나 저장 공간을 효율적으로 사용하기 위해 여러 테이블로 분리하는 과정이다.

`정규형 원칙` 정규형의 원칙이란 같은 의미를 표현하는 테이블이지만 좀 더 좋은 구조로 만들어야 하고 자료의 중복성 감소, 독립적인 관계는 별개의 테이블로 표현해야 하며, 각각의 테이블은 독립적인 표현이 가능해야하는 것을 말한다.

`제1정규형` 테이블의 모든 도메인이 더 이상 분해될 수 없는 원자 값으로만 구성되어야 한다.

`제2정규형` 테이블이 제1정규형을 만족하고 부분 함수의 종속성을 제거한 형태이다. 부분함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말한다.

`제3정규형` 테이블이 제2정규형을 만족하고 기본키가 아닌 모든 속성이 이행적 함수 종적을 만족하지 않는 상태이다. 이행적 함수 종속이란 A->B와 B->C가 존재하면 논리적으로 A->C가 성립하는데, 이때 집합 C가 집합 A에 이행적으로 함수 종속되었다고 한다.

## 🟠 트랜잭션과 무결성

### 🟢 트랜잭션

트랜잭션은 DB에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말하며 여러 개의 쿼리들을 하나로 묶는 단위를 말한다. 특징으로 원자성, 일관성, 독립성, 지속성이 있고 이를 ACID라고 한다.

`원자성` 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장한다.

`일관성` 허용된 방식으로만 데이터를 변경해야된다는 것을 의미한다.

`격리성` 트랜잭션 수행 시 서로 끼어들지 못하는 것을 보장한다.

`지속성` 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.

### 🟢 트랜잭션 전파

트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 한다. 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 한다. Spring에서는 @Transaction을 통해 여러 쿼리 관련 코드들을 하나로 묶어 전파한다.

### 🟢 Spring에서 트랜잭션 전파

REQUIRED, SUPPORTS, MANDATORY, REQUIRES_NEW, NOT_SUPPORTED, NEVER, NESTED 7가지가 있다.

`REQUIRED` default 속성으로 모든 트랜잭션을 매니저가 지원한다. 미리 시작된 트랜잭션이 있다면(부모) 해당 트랜잭션에 참여하고 없다면 새롭게 만든다.
`SUPPORTS` 이미 시작된 트랜잭션이 있다면 참여하고 없다면 트랜잭션 없이 진행된다.
`MANDATORY` 이미 시작된 트랜잭션이 있으면 참여한다. 없다면 예외를 발생시킨다. - 혼자서 독립적으로 트랜잭션을 진행하면 안되는 경우에 처리
`REQUIRES_NEW` 항상 새로운 트랜잭션으로 시작한다. 이미 시작된 트랜잭션이 있다면 잠시 보류시키고 새로운 트랜잭션으로 우선 처리한다.
`NOT_SUPPORTED` 이미 진행중인 트랜잭션이 있다면 이를 보류시키고, 트랜잭션을 사용하지 않고 진행한다.
`NEVER` 이미 진행중인 트랜잭션이 있다면 예외를 발생시킨다 - 트랜잭션을 사용하지 않도록 강제
`NESTED` 이미 진행중인 트랜잭션이 있으면 자식 트랜잭션을 시작한다. 트랜잭션 안에 다시 트랜잭션을 만드는 것으로 REQUIRES_NEW와는 다르게 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만 자신의 커밋과 롤백은 부모에게 영향을 주지 않는다.


### 🟢 트랜잭션 격리 수준

격리 수준은 SERIALIZABLE, REPEATABLE_READ, READ_COMMITED, READ_UNCOMMITED 가 있고 위로 갈수록 동시성이 강해지지만 격리성이 약해진다.

격리 수준에 따라 발생하는 현상은 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 있다.

`SERIALIZABLE` 트랜잭션을 순차적으로 진행시켜 동시에 접근할 수 없고 엄격한 격리 수준이다. 성능이 떨이지고 데드락이 발생할 확률이 높다.

`REPEATABLE_READ` 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않는다. MySQL8.0 기본값이다.

`READ_COMMITED` 가장 많이 사용되는 격리 수준이며, 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 조회중인 트랜잭션이 있더라도 다른 트랜잭션에서 수정이 일어날 수 있다.

`READ_UNCOMMITED` 가장 낮은 수준의 격리 수준으로, 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출될 수 있다. 하지만 가장 빠르다. 정확하지 않아도 되는 데이터를 대량으로 조회할때 사용할 수 있다.

`phantom read` 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우다.

`non-repeatable read` 트랜잭션 내의 같은 행에 두번 이상 조회가 발생했는데, 그 값이 다른 경우다.

`dirty read` 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않는 상태의 행 데이터를 읽었을 때 발생한다.

REPEATABLE_READ는 팬텀리드,

READ_COMMITED는 팬텀리드 반복 가능하지 않은 조회

READ_UNCOMMITED는 팬텀리드, 반복 가능하지 않은 조회, 더티 리드가 발생할 수 있다.

Spring에서의 기본 값은 READ_COMMITTED이다.

## 🟠 인덱스

### 🟢 인덱스의 필요성

인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다.

### 🟢 B-tree

인덱스는 보통 B-tree 구조로 이루어져 있다. 이는 루트 노드, 리프 노드, 브랜치 노드로 나뉜다.

### 🟢 인덱스 최적화 기법

인덱스는 최소 두번 탐색을 강요한다. 풀스캔과는 다르게 인덱스를 먼저 확인하고 데이터를 찾아가기 때문이다. 그에 따른 읽기 비용이 발생하고 데이터를 수정, 추가, 삭제시에도 데이터만 변경되는 것이 아닌 인덱스를 추가로 수정해야하기에 비용이 든다.

그렇기에 인덱스가 항상 효율이 좋을 순 없다.

`테스트` explain 함수를 통해 인덱스가 쿼리에서 적용되는지 확인을 하자

`복합 인덱스` 여러 필드를 기반으로 조회할 때 복합 인덱스를 생성하는데 이 인덱스를 생성할때 순서가 있고 순서에 따라 성능이 달라진다.

같음(==, equal) > 정렬(order by) > 다중값(>, <) > 카디널리티(유니크한 값의 정도가 높은 것) 순서로 생성해야한다.

## 🟠 join

### 🟢 inner join

두 테이블간의 교집합

### 🟢 left outer join

A, B 테이블에서 A 테이블 기준 완전한 레코드 집합을 생성하고 B에 일치하는 항목이 없다면 null로 노출된다.

### 🟢 right outer join

A, B 테이블에서 B 테이블 기준 완전한 레코드 집합을 생성하고 A에 일치하는 항목이 없다면 null로 노출된다.

### 🟢 full outer join

두 테이블에서 일치하는 레코드와 함께 A, B 테이블 모든 레코드 집합을 생성한다. 이때 일치하는 항목이 없으면 누락된 쪽에 null이 포함되어 노출된다.

## 🟠 join 원리

위에서 설명한 조인은 조인 원리를 기반으로 조인 작업이 이루어진다. 중첩 루프 조인, 정렬 병합 조인, 해시 조인이 있다.

### 🟢 중첩 루프 조인

중첩 for문과 같은 원리로 조건에 맞는 조인을 하나씩 찾아 접근하여 처리한다.

### 🟢 정렬 병합 조인

각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행한다. 조인할 때 쓸 적절한 인덱스가 없고 >,< 등 범위 비교 연산자가 있을 때 쓴다.

### 🟢 해시 조인

해시 테이블을 기반으로 조인하는 방법이다. 두 개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 중첩 루프 조인보다 더 효율적이다. == 비교 조인에서만 사용할 수 있다.