# 🔴 기술 면접 준비 시작

## 🟠 자기소개

```text
안녕하세요 6년차 개발자 최준호입니다.
저는 코드블럭이라는 PG사에서 경력을 시작하여 현재는 카카오vx에 근무하고 있습니다.
해당 회사들을 통해 레거시 개선, 성능 최적화, 트러블 슈팅, 협업의 경험을 쌓았습니다.

비댁스는 커스터디 사업을 하는 금융, 블럭체인 회사로 알고 있습니다.
금융 관련된 도메인은 안정성과 신뢰성이 중요한 사업이라 생각합니다.

저의 안정적인 운영 능력과 트러블 슈팅 능력은 비댁스에서 안정성과 신뢰성에 기여할 수 있다 확신합니다.
또한 개발자 분들과의 커피챗을 통해 회사의 개발 문화와 역량이 인상이 깊었고
합류한다면 저도 그 안에서 기술적으로 기여하면서 금융 도메인 전문성을 키울 수 있다고 확신하였습니다.
좋은 동료들과 함께 성장하고 회사와 함께 성장하고 싶습니다.
감사합니다.
```

## 🟠 1차 기술

### 🟢 가장 기억에 남는 프로젝트

```text
ERP 연동 시스템 프로젝트가 OOM 문제 해결과 레거시 개선을 진행한 프로젝트로 가장 기억에 남습니다.
```

### 🟢 OOM 문제 해결에 대해 자세히 설명

```text
정상적으로 동작하던 시스템이 주말간 갑자기 다운되었던 문제였는데요.
jvm 옵션으로 oom 발생시 jmap 파일을 남기도록 설정되어 있어서 해당 파일을 intellij를 통해 분석할 수 있었고
객체중 메모리 사용량이 가장 높은 객체를 의심하였고 정상 시스템이 갑자기 다운되었기 때문에 깃로그 상 가장 최근에 변경된 객체를 추적하려고 하였습니다.
그 중 LinkedBlockingQueue가 가장 의심되어 해당 객체를 분석해보았고 내부 로직상 put할 때는 병렬 쓰레드로 빠르게 넣지만
read의 경우는 단일 스레드로 하고 있어서 속도 차이로 인해 무한큐로 모델링 된 LinkedBlockingQueue에 데이터가 쌓여 jvm에서 메모리 부족으로 oom이 발생했던 부분이였습니다.

무제한 큐이기 때문에 문제 해결을 위해 케파를 설정하였고 LinkedBlockingQueue 내부적으로 케파 이상 데이터가 들어올 경우 await을 해주어
성능 측면에서는 좀 아쉬워지지만 안정성 측면을 챙길 수 있는 trade off 경험이였습니다.
```

### 🟢 레거시 개선에 대해 자세히 설명

```text
ERP 연동 시스템은 외부 ERP 업체에 대한 연동 소스와 내부 처리 로직 소스가 하나의 클래스 서비스 로직으로 섞여 있는 크고 복잡한 소스였습니다.
이 문제 해결을 위해 외부 호출과 내부 로직을 나누고 디자인 패턴을 적용하여 코드를 확장성과 가용성 있도록 변경하는 경험을 진행하였었습니다. 
```

### 🟢 레거시 개선에 대해 자세히 설명 - 디자인 패턴 어떤거 어떻게 적용?

```text
외부의 ERP 호출을 기존에는 업체별 서비스가 뭉쳐있었는데요. 그부분을 각 골프장 업체별 Factory class를 구현하여 분리하여 골프장별 요구사항으로 인한 하드코딩을 분리할 수 있었습니다.
그리고 ERP 업체 호출 후 반환되는 데이터도 같은 업체에서 골프장별로 다른 경우도 있었는데요 이를 처리하기 위해 Adapter 패턴을 적용하여 내부에서 사용될 수 있는 데이터로 변환하는 처리를 하였습니다.
마지막으로 골프장별 요구사항으로 인해 내부 로직에 하드코딩을 적용해야되는 경우가 있었는데요. 이를 위해 전략 패턴을 적용하여 전략이 존재하는 경우에는 내부로직이 따로 처리되도록 처리하였습니다.
이로 인해 기존 4500줄 이상의 로직과 하드코딩이 뒤섞여서 분석이 어려웠던 코드가 4개의 클래스로 400줄 이하의 코드로 변경되었고 각 골프장별로 적용이 가능해져 로직 수정시 전체 서비스의 영향이 가지 않고 각 골프장별 영향을 가지게 되어
서비스의 안정성과 확장성에 기여할 수 있었습니다.
```

### 🟢 Redis를 사용해서 최적화한 경험 설명

```text
메인 페이지에 계속해서 내려가는 데이터 중 read가 오래 걸리는 데이터가 있었고 해당 데이터를 redis를 통해 캐싱하여 처리하였습니다.
로컬 캐싱을 사용하지 않고 Redis를 사용한 이유는 우선 분산 시스템이라 로컬 캐싱은 서버마다 캐싱되기에 각 서버마다 다른 데이터가 내려갈 수도 있었고
Redis를 이미 프로젝트에서 사용중이였기에 사용할 수 있었습니다.

캐싱 무효화 전략으로는 데이터가 변경되었을 때 Redis의 캐싱된 데이터도 업데이트를 하여 처리하는 방식으로 처리하였습니다.
```

### 🟢 이직 사유

```text
최근 회사가 구조조정과 희망퇴직을 반복하면서 프로젝트가 무기한 보류되거나 중단되는 경우가 많아졌습니다. 
이로 인해 펜딩 되거나 엎어지는 프로젝트들이 많아졌고 회사의 발전과 저의 발전 모두 멈춘 기분이였습니다.
그로 인해 좀더 발전할 수 있는 회사에서 근무하고 싶어 이직을 결심하였습니다.
```

### 🟢 지원 동기

```text
우선 국내에서 아직 많이 경험할 수 없는 도메인을 다루는 회사이고 앞으로 유망한 도메인이라 생각이 들었습니다.
또한 국내에서 비슷한 업체가 몇개 있는 것으로 알고 있는데 비댁스는 특히 국외 사업체와의 기술적 제휴나 투자가 활발히 이뤄지고 있기에 글로벌 서비스로서 성장할 수 있다고 생각하였습니다.
한국에서 글로벌로 성장하며 앞으로 미래가 유망한 도메인으로 회사와 함께 성장할 수 있는 경험은 개발자로서 엄청난 경험이라 생각하기에 비댁스에 지원하였습니다.
```

### 🟢 갈등 경험(상사)

```text
하드코딩으로 인해 팀장님과의 갈등이 있었던 경험이 있습니다.
하드코딩은 서비스의 안정성을 해치고 이후 로직 수정시 알수 없는 문제를 일으킬 수 있어 최대한 지양해야된다 생각했기에 하드코딩보다 서비스를 만들자는 의견을 전달했습니다.
하지만 팀장님께서는 현재 우리에게 그러한 리소스가 없고 시간이 없다고 하셨고 우리 팀의 목적은 경쟁사보다 빠르게 하나의 서비스를 더 제공하고
고객들에게는 더 많은 이벤트와 선택지를 제공하는게 목표라 하셨습니다. 회사 차원의 목표와 팀 차원의 목표였기에 저는 그 말에 수긍하였고 대신 하드코딩을 기존 방식에서
하드코딩용 클래스로 따로 빼서 작업하기로 하여서 기존에 소스에 여기저기 섞여 있던 소스를 하나의 클래스로 빼서 관리하도록 처리했습니다.
그 결과로 이후에 레거시를 개선할 때 하드코딩들을 빠르게 분리하고 사용되지 않는 하드코딩들을 지워갈 수 있었습니다.
```

### 🟢 갈등 경험(팀원)

```text
docker, jenkins를 도입하며 팀원들과의 의견을 주고받은 경험이 있습니다.
당시 팀원들은 저보다 리눅스 활용 능력이 뛰어났기 때문에 현재 배포 프로세스에 대해 불만이 없었습니다.
오히려 docker와 jenkins의 도입은 팀원들에게 부담이라는 의견이 있었는데요.
이 부분을 해결하기 위해 팀원들에게 혹시라도 문제가 발생한다면 제가 직접 가서 도와주고 같이 문제를 해결해줄 수 있다고 했고
팀원들을 위한 교육 시간도 마련하기로 하였습니다. 대표님과 팀장님에게는 문서와 실습 과정을 직접 시연하여 현재 배포가 1시간이 걸리는 것에 비해
새로운 인원이 투입된다 하여도 5분안에 배포가 가능하고 jenkins의 동작도 기존 리눅스 명령어를 그대로 사용함으로써 현재 인원들도 금방 적응할 수 있도록 적용할 수 있다는 것을 보였습니다.
그 결과 대표님과 팀장님의 승인으로 회의시간을 따로 잡아주셔서 팀원들에게 시연과 교육을 진행하였고 실제로 제가 퇴사 이후에도 현재도 도커와 jenkins를 통해 잘 배포하고 있다고 들었습니다.
```

### 🟢 요즘 읽고있거나 공부하고 있는 분야

```text
요즘에는 AI 개발툴을 활용해보는 부분에 대해 고민해보고 공부하고 있습니다.
cursor를 사용하여 바이브 코딩을 진행해보거나 ollama를 사용하여 로컬에 ai를 실행하여 실제 ai 서비스를 만들어보는 등 적용해보고 있습니다.
```

### 🟢 사용하면서 느낀점

```text
확실히 ai를 통해 생산성은 매우 높아진다고 생각합니다. 저는 ai를 보면서 개발자의 시장이 이후에 변화가 생길거라 확신하는데요.
이전에 양말 공장에서 미싱을 잘 돌리는 직원이 가장 뛰어난 직원이였다면 현재 양말 공장에서는 미싱을 잘 돌리는 직원은 필요가 없습니다.
기계를 작동시키는 방법에 대해 이해하고 양말 디자인 도면을 볼줄 알고 기계가 문제가 생겼을때 문제를 해결할 수 있는 사람이 필요합니다.
이와 같이 이후 개발자의 세계 또한 AI로 인해 알고리즘과 코드를 화려하게 잘 짜는 사람보다 전체 아키텍처를 볼줄 알고 트러블 슈팅을 잘 할줄 아는 개발자가 살아남겠다고 느꼈습니다.
```

### 🟢 궁금한 점

```text
비댁스에 근무하면서 가장 좋은 부분은 어떤 부분이 있으실까요? 복지? 연봉? 동료?
```

## 🟠 기본 cs
1. JVM
    - class loader, runtime data area, execution engine으로 구성
    - class loader는 class를 실제 실행하기 위한 코드로 읽어오고 jvm에 배치해주는 역할
    - runtime data area는 jvm의 메모리 영역
    - execution engine은 실제 코드를 한줄씩 실행하는 interpreter와 병렬 실행하는 jit compiler, gc로 구성
    - runtime data area는 method area, heap area, stack area, native area, pc register로 구성
    - method에서는 static, method 등 프로그램이 실행할때 생성되고 명시적으로 null로 처리할때까지 살아있는 모든 쓰레드들이 공유하는 객체들이 존재
    - heap은 new 객체로 생성된 객체들이 존재
    - stack은 메서드의 실행 순서와 메서드 내 필드들이 임시로 저장되는 공간
    - native area는 java에서 os의 기능 실행하기 위한 공간
    - pc register는 각 스레드가 어떤 명령어를 실행중인지 명령어 주소 저장 공간
2. GC
    - young, old 영역
    - young은 eden(최초 생성), survive0, survive1 영역으로 나누어서 구분됨
    - GC의 종류는 young을 지우는 Minor GC, old를 지우는 Major GC로 구분됨
    - 영역 메모리가 가득 차면 영역 메모리 gc
    - 메모리가 gc에 오랫동안 걸리지 않아 old가 계속 차게 되면 메모리 사용량 증가
    - gc가 자주 발생하면 응답 지연 발생 가능성이 높다 (stop the world)
    - 기본 gc 알고리즘은 G1으로 설정되어 있음
    - GC 튜닝은 정말 최후 최후의 방법임. 코드레벨에서 먼저 개선할 것
3. hash 구조
    - 해시 function
    - 입력 받은 데이터를 해시 값으로 변환
    - 해시 테이블
        - 변환 된 값을 key로 key-value 형태로 저장하는 테이블
    - 해싱
        - 키값을 해시 함수를 통해 해시 테이블로 저장하는 과정
    - 해시 충돌
        - 해시 값을 만들었을때 중복되는 경우를 해시 충돌이라 한다.
        - 충돌 해결로는 open address 또는 chaning 기법이 있고 java는 chaning 기법을 사용한다.
        - linked list 형태로 충돌되는 데이터를 저장하다가 특정 조건 이상 충돌이 발생하면 트리 구조로 변경한다.
            - java의 특정 조건은 맵의 총 크기가 64 이상이고 해당 충돌값이 8개 이상인 경우 트리로 변경한다.
            - 만약 맵 총 크기가 64 미만이고 충돌이 8번 이상 발생한 경우는 resize()를 통해 해시를 재생성하여 해시테이블을 새롭게 만들어 정렬한다.
        - 데이터가 많은 경우 트리구조로 변경되어 읽기시 최대 O(n) 복잡도가 걸릴 수 있는 부분은 O(log n)으로 줄이기 위함니다.
4. list 구조
    - ArrayList 기본 구조
        - 조회가 빠르다. 삽입/삭제시 재생성해야 되므로 느리다.
        - 최초 생성시 static으로 내부적으로 생성되어 있는 Object[] 로만 생성 : 메모리를 사용하지 않기 위함
        - add()를 실행할 경우 size가 크다면 grow()를 통해 resize를 진행, 새로운 사이즈는 기존 크기의 1.5배, 최초로 할 경우는 default 값이 10으로 크기 설정
        - size()의 경우 내부적으로 int size 값으로 관리하고 있어 object의 길이만큼을 반환하지 않고 size 값으로 반환함
        - Object[]의 일급 컬렉션과 같은 느낌
    - LinkedList 기본 구조
        - 조회가 연결된 부분을 모두 탐색해야 되어 느리다. 삽입/삭제가 해당 부분에 다음 링크로 넣기만 하면 돼서 빠르다.
        - 연결된 node 구조로 리스트가 아닌 first, last, size 값만을 가진 class를 만든다.
        - node가 추가되면 new Node<>(last 노드, 새로운 값, null)를 통해 노드를 추가하고 last에 새롭게 생성된 node를 넣어준다. 기존 값이 null인 경우 first에도 해당 node를 넣어준다.
        - node가 기존에 값이 존재했다면 new Node<>()를 통해 노드를 추가하고 last 노드의 next 값으로 넣어준다. 이렇게 계속 연결해 나간다.
    ```java
    private static class Node<E> {
       E item;
       Node<E> next;
       Node<E> prev;
    
       Node(Node<E> prev, E element, Node<E> next) {
           this.item = element;
           this.next = next;
           this.prev = prev;
       }
    }
    ```
5. DB 최적화
    - 인덱싱 (인덱싱 순서로 =, 정렬 순서, 범위, 카디널리티로 처리)
    - 정규화 (통계를 위한 통계 디비로 정규화 작업, 데이터가 너무 많이 쌓여 연도별 테이블 정규화 작업)
    - explain 명령어를 통해 확인
6. spring 구조
    - request 흐름
        - request -> dispatcher servlet -> handler mapping 확인 -> handler adapter에서 controller 호출 -> contoller 데이터 반환 -> view resolver / message converter 데이터 반환
    - bean/component 등록
        - @Bean or @Component 사용하여 등록 -> @ComponentScan을 통해 프로젝트를 스캔 -> ApplicationContext에 등록 -> 필요 부분에 자동 주입
7. filter, aop, interceptor
    - filter
        - 클라이언트에서 요청을 보낼때 서버쪽에서 가장 먼저 동작
        - 인증 필터로 사용
    - interceptor
        - 컨트롤러에 진입하기 직전에 동작
        - 권한 체크로 사용
    - aop
        - 메서드의 동작 전/후로 작동
        - 메서드 로그로 사용
8. Transaction
    - 트랜잭션 격리 수준
        - 격리 수준에 따라 phantom read, non-repeatable read, dirty read 증상이 발생할 수 있다.
        - 격리 수준은 SERIALIZABLE(가장 엄격), REPEATABLE_READ(phantom read), READ_COMMITED(a+non-repeatable read), READ_UNCOMMITED(a+b+dirty read) 가 존재한다.
        - spring의 기본 격리 수준은 READ_COMMITED 이다.
    - 트랜잭션 전파 수준
        - REQUIRED, SUPPORTS, MANDATORY, REQUIRES_NEW, NOT_SUPPORTED, NEVER, NESTED가 있다.
        - `REQUIRED(default)` 시작 트랜잭션이 있다면 모두 부모 트랜잭션으로 참여하게 만들고 없다면 새롭게 만든다.
        - `SUPPORTS` 이미 시작된 트랜잭션이 있다면 참여하고 없다면 없이 진행한다.
        - `MANDATORY` 이미 시작된 트랜잭션이 있다면 참여하고 없다면 예외가 발생한다.
        - `REQUIRES_NEW` 이미 진행중인 트랜잭션이 있다면 이를 보류시키고, 새로운 트랜잭션을 사용한다.
        - `NOT_SUPPORTED` 이미 진행 중인 트랜잭션이 있다면 이를 보류시키고, 트랜잭션을 사용하지 않고 진행한다.
        - `NEVER` 이미 진행중인 트랜잭션이 있다면 예외가 발생한다.
        - `NESTED` 이미 진행중인 트랜잭션이 있다면 자식 트랜잭션을 시작한다. 트랜잭션 안에 다시 트랜잭션을 만드는 것으로 자신의 커밋과 롤백은 부모에게 영향을 주지 않는다.
9. join
    - inner join = join
    - left outer join = left join
    - right outer join = right join
    - full outer join = union
10. 정규화
    - `1정규화` 1row에는 1개의 데이터만
    - `2정규화` 현재 테이블과 관련 없는 데이터는 다른 테이블로
    - `3정규화` 일반 컬럼에 종속된 데이터는 다른 테이블로 빼기